#
# MIT License
#
# (C) Copyright 2022 Hewlett Packard Enterprise Development LP
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
name: Build Artifacts

# Globals
env:

  # Package/artifact names
  IMAGE_NAME: cf-gitea-import
  
  # Artifact repository locations
  REGISTRY: artifactory.algol60.net
  REGISTRY_USERNAME: github-actions-cray-hpe
  REGISTRY_DOWNLOAD_PATH: artifactory
  IMAGE_REPOSITORY: csm-docker

  # Code checker variables
  SNYK_SEVERITY_THRESHOLD: high

on:

  push:
    # Do not build pushes to the main/master branch, tags build prod releases
    # Do not build release branches from historical CSM/Shasta release branches
    branches:
      - feature/**
      - hotfix/**
      - support/**
      - develop
      - 'release/**'
      - '!release/csm-**'
      - '!release/shasta-**'

  # Make this a reusable workflow for the purposes of building production
  # releases from tags on main/master, or beta releases from release or hotfix
  # branches.
  workflow_call:
    secrets:
      SNYK_TOKEN:
        required: true
      ARTIFACTORY_ALGOL60_JFROG_CLI_CONFIGURATION:
        required: true
      ARTIFACTORY_ALGOL60_USERNAME:
        required: true
      ARTIFACTORY_ALGOL60_TOKEN:
        required: true
      COSIGN_GCP_PROJECT_ID:
        required: true
      COSIGN_GCP_SA_KEY:
        required: true
      COSIGN_KEY:
        required: true
    outputs:
      run-id:
        value: ${{ jobs.publish-artifacts.outputs.run-id }}
      semVer:
        value: ${{ jobs.build-prep.outputs.semVer }}
      image-version:
        value: ${{ jobs.build-prep.outputs.image-version }}
      is-stable:
        value: ${{ jobs.build-prep.outputs.is-stable }}
      build-date-time:
        value: ${{ jobs.build-prep.outputs.build-date-time }}
      image:
        value: ${{ jobs.publish-artifacts.outputs.image }}
      image_url:
        value: ${{ jobs.publish-artifacts.outputs.image_url }}

# Workflow Jobs
jobs:

  build-prep:
    runs-on: self-hosted
    outputs:
      semVer: ${{ steps.buildprepversion.outputs.version }}
      image-version: ${{ steps.buildversion.outputs.image-version }}
      is-stable: ${{ steps.buildprepversion.outputs.is-stable }}
      build-date-time: ${{ steps.buildprepversion.outputs.build-date-time }}
      short-sha: ${{ steps.buildprepversion.outputs.short-sha }}
      major: ${{ steps.buildprepversion.outputs.major }}
      minor: ${{ steps.buildprepversion.outputs.minor }}
      patch: ${{ steps.buildprepversion.outputs.patch }}
      commits-since-last-version: ${{ steps.buildprepversion.outputs.commits-since-last-version }}
      pre-release-tag: ${{ steps.buildprepversion.outputs.pre-release-tag }}

    steps:
      - name: Prep build metdata and fetch version
        id: buildprepversion
        uses: Cray-HPE/.github/actions/csm-run-build-prep@v2-csm-run-build-prep

      - name: Set version info
        id: buildversion
        shell: bash
        run: |
          echo ::set-output name=pre-release-tag::$(echo ${{ env.GITVERSION_PRERELEASETAG }})
          if [[ "${{ env.GITVERSION_PRERELEASETAG }}" = "" ]]; then
            echo ::set-output name=image-version::$(echo ${{ steps.buildprepversion.outputs.version }}-${{ steps.buildprepversion.outputs.build-date-time }}.${{ steps.buildprepversion.outputs.short-sha }})
          else
            echo ::set-output name=image-version::$(echo ${{ steps.buildprepversion.outputs.version }}.${{ steps.buildprepversion.outputs.build-date-time }}.${{ steps.buildprepversion.outputs.short-sha }})
          fi
          if [[ ${{ steps.buildprepversion.outputs.is-stable }} = unstable ]]; then
            echo ::set-output name=py-version::$(echo ${{ steps.buildprepversion.outputs.major }}.${{ steps.buildprepversion.outputs.minor }}.${{ steps.buildprepversion.outputs.patch }}.dev${{ steps.buildprepversion.outputs.commits-since-last-version }})
          else
            echo ::set-output name=py-version::$(echo ${{ steps.buildprepversion.outputs.major }}.${{ steps.buildprepversion.outputs.minor }}.${{ steps.buildprepversion.outputs.patch }})
          fi

  build-scan-sign-publish-image:
    runs-on: ubuntu-latest
    needs: build-prep
    outputs:
      full-image: ${{ steps.buildvars.outputs.full-image }}
      full-image-download-path: ${{ steps.buildvars.outputs.image-download }}
      image-base: ${{ steps.buildvars.outputs.image-base }}
      image-tag: ${{ steps.buildvars.outputs.image-tag }}
      snyk-passed: ${{ steps.snyk-result.outputs.snyk-passed }}

    steps:
      - uses: actions/checkout@v2
      - name: Set variables
        id: buildvars
        run: |
          echo ::set-output name=image-base::$(echo ${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/${{ needs.build-prep.outputs.is-stable }}/${{ env.IMAGE_NAME }})
          echo ::set-output name=image-tag::$(echo ${{ needs.build-prep.outputs.image-version }})
          echo ::set-output name=full-image::$(echo ${{ env.REGISTRY }}/${{ env.IMAGE_REPOSITORY }}/${{ needs.build-prep.outputs.is-stable }}/${{ env.IMAGE_NAME }}:${{ needs.build-prep.outputs.image-version }})
          echo ::set-output name=image-download::$(echo ${{ env.REGISTRY }}/${{ env.REGISTRY_DOWNLOAD_PATH }}/${{ env.IMAGE_REPOSITORY }}/${{ needs.build-prep.outputs.is-stable }}/${{ env.IMAGE_NAME }}:${{ needs.build-prep.outputs.image-version }})

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v3
        with:
          images: ${{ steps.buildvars.outputs.image-base }}
          tags: |
            type=semver,pattern={{version}},value=${{ steps.buildvars.outputs.image-tag }}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
          labels: |
            org.opencontainers.image.vendor=Hewlett Packard Enterprise Development LP

      # Build and load the image into the local docker registry first. This
      # allows it to undergo security scans before being pushed to the remote
      # registry.
      - name: Build Image (local build, no push)
        uses: docker/build-push-action@v2
        id: build-docker-image
        with:
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

      - name: Save the Docker Image
        shell: bash
        run: |
          docker save ${{ steps.buildvars.outputs.image-base }}:${{ steps.buildvars.outputs.image-tag }} | gzip > docker-image.tar.gz

      - name: Upload Docker image as Build Artifact
        uses: actions/upload-artifact@v2
        with:
          name: docker-image
          path: docker-image.tar.gz
          retention-days: 90

      # Run the scanner, continue on if errors are found so the results can be
      # reported to the Github Code Scanning alerts tab
      - name: Run Snyk to check Docker images for vulnerabilities
        uses: snyk/actions/docker@master
        id: snyk-scan
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ${{ steps.buildvars.outputs.full-image }}
          args: --severity-threshold=${{ env.SNYK_SEVERITY_THRESHOLD }} --skip-unresolved=true --file=Dockerfile
          sarif: true
          json: true

      - name: Get Snyk Result
        id: snyk-result
        run: |
          echo ::set-output name=snyk-passed::$(echo `cat snyk.json | jq -r .ok`)

      - name: Upload Snyk result to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v1
        id: snyk-upload
        with:
          sarif_file: snyk.sarif

      # Push the image to the remote registry if the snyk scan was clean
      - name: Login to algol60 Container Registry
        if: ${{ fromJSON(steps.snyk-result.outputs.snyk-passed) }}
        uses: docker/login-action@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ secrets.ARTIFACTORY_ALGOL60_TOKEN }}

      - name: Push Image tags to registry
        if: ${{ fromJSON(steps.snyk-result.outputs.snyk-passed) }}
        uses: docker/build-push-action@v2
        id: push-docker-image
        with:
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  sign-image-sbom:
    runs-on: ubuntu-latest
    if: ${{ fromJSON(needs.build-scan-sign-publish-image.outputs.snyk-passed) }}
    needs: 
      - build-scan-sign-publish-image

    steps:

      - name: Sign the image in Artifactory
        id: image-sign
        uses: Cray-HPE/.github/actions/csm-sign-image@v2-csm-sign-image
        with:
          cosign-gcp-project-id: ${{ secrets.COSIGN_GCP_PROJECT_ID }}
          cosign-gcp-sa-key: ${{ secrets.COSIGN_GCP_SA_KEY }}
          cosign-key: ${{ secrets.COSIGN_KEY }}
          registry: ${{ env.REGISTRY }}
          registry-username: ${{ env.REGISTRY_USERNAME }}
          registry-password: ${{ secrets.ARTIFACTORY_ALGOL60_TOKEN }}
          github-sha: ${{ env.GITHUB_SHA }}
          image: ${{ needs.build-scan-sign-publish-image.outputs.full-image }}

      - name: Generate, Attach, and Sign container image SBOM
        uses: Cray-HPE/.github/actions/csm-generate-attach-sign-sbom@v1-csm-generate-attach-sign-sbom
        id: sbom
        with:
          cosign-gcp-project-id: ${{ secrets.COSIGN_GCP_PROJECT_ID }}
          cosign-gcp-sa-key: ${{ secrets.COSIGN_GCP_SA_KEY }}
          cosign-key: ${{ secrets.COSIGN_KEY }}
          registry: ${{ env.REGISTRY }}
          registry-username: ${{ secrets.ARTIFACTORY_ALGOL60_USERNAME }}
          registry-password: ${{ secrets.ARTIFACTORY_ALGOL60_TOKEN }}
          github-sha: ${{ env.GITHUB_SHA }}
          image: ${{ needs.build-scan-sign-publish-image.outputs.full-image }}

  publish-artifacts:
    runs-on: ubuntu-latest
    if: ${{ fromJSON(needs.build-scan-sign-publish-image.outputs.snyk-passed) }}
    needs:
      - build-prep
      - build-scan-sign-publish-image
    env:
      IMAGE_TAG: ${{ needs.build-scan-sign-publish-image.outputs.image-tag }}
      STABLE: ${{ needs.build-prep.outputs.is-stable }}
    outputs:
      run-id: ${{ github.run_id }}
      image: ${{ steps.vars.outputs.image }}
      image_tag: ${{ steps.vars.outputs.image_tag }}
      image_url: ${{ steps.vars.outputs.image_url }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v2

      - name: Create additional template vars
        id: vars
        run: |
          echo ::set-output name=image::$(echo ${IMAGE_NAME}:${IMAGE_TAG})
          echo ::set-output name=image_tag::$(echo ${IMAGE_TAG})
          echo ::set-output name=image_url::$(echo https://artifactory.algol60.net/ui/repos/tree/General/csm-docker%2F${STABLE}%2F${IMAGE_NAME}%2F${IMAGE_TAG})

      - name: Capture the artifactory locations of the build artifacts
        uses: schdck/create-env-json@v2
        with:
          file-name: 'artifacts.json'
          image: ${{ steps.vars.outputs.image }}
          image_tag: ${{ steps.vars.outputs.image_tag }}
          image_url: ${{ steps.vars.outputs.image_url }}

      - name: Upload artifactory artifact metadata as a Build Artifact
        uses: actions/upload-artifact@v2
        with:
          name: artifacts.json
          path: artifacts.json
          retention-days: 90
